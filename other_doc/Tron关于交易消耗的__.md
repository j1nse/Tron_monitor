[TOC]



#  总结(对后面的总结)

## 总结

要确定一个账户在某一块的balance，就得找到所有跟这个账户有关的合约(交易)，然后计算他地Energy 和Bandwidth Points的使用情况。然后加上转账交易额，应该就可以了。

使用情况就是，根据下面的计算，如果E和BP不够就会使用TRX余额代替。

**不过很多账户都没有冻结TRX，也就是没有额外的E和BP。计算会比较容易。**

## 计算方面

相比于Ether的gas，Tron有2种资源：Energy 和 Bandwidth Points.

1个Energy可以让CPU为你运行1秒，1个Bandwidth Points可以让你处理一字节的transaction.

获取E：冻结自己的TRX，可以按比例获得E，也就是说只要你冻的比别人多就可以获得更多的E. 计算公式:`获得的能量=为获得能量而冻结的TRX /为在整个网络中获得能量而冻结的总TRX * 50_000_000_000`

获取BP:每个账户每天会获得5000个免费的BP，然后可以用冻结TRX来获取。计算公式`帐户中的带宽点:TRON网络的带宽容量 == 帐户中的冻结余额:整个网络上的冻结余额`

**当E不足时：扣除所需的能量* 20 SUN**

**当BP不足时：扣除transaction中的字节数 * 10 SUN**

超级代表：127个候选人里选27个代表.

每6小时更新一次候选人名单，发放一次候选人奖励

候选人奖励：每个块的奖励为16 TRX。计算：`1382400/生成块速度`，然后根据得票占比分配

代表奖励：每个块向超级代表授予32 TRX



# 介绍

## Energy

智能合约的创建和运行会消耗CPU资源。 智能合约在虚拟机（VM）中运行需要时间，系统消耗的时间以微秒为单位计算。 CPU资源在能量中消耗，这意味着1Energy == 1微秒。 如果合同在VM中执行需要100微秒，则需要消耗100 Energy。 TRON网络提供的总CPU资源在24小时内有50,000,000,000能量。

能量只能通过冻结TRX来获得。 `获得的能量=为获得能量而冻结的TRX /为在整个网络中获得能量而冻结的总TRX * 50_000_000_000`，这是基于冻结TRX的所有用户的等分固定能量。

例如，假设在当前网络中冻结获取能量的TRX总量为1000_000_000 TRX，并且一个帐户冻结1000 TRX，这是总数的百万分之一并且等于32400微秒(??这怎么算出来的)。 如果执行合同需要324微秒，那么用户可以触发合同100次。

由于网络中的冻结资金总额和冻结的账户资金可能随时发生变化，因此账户拥有的CPU资源不固定。
在冻结资金的过程中，无法获得带宽积分能量.(One cannot get both Bandwidth Points and Energy when freezing funds.) 如果你冻结TRX以获得带宽，那么你的能量将不会改变(???能量不也是冻结TRX得来的吗)。

### 能源消耗

智能合约的创建和执行消耗能源，而其他正常交易不消耗能源。

### 能量计算方法
能量消耗如下：

尝试消耗交易发起人(transaction initiator)的通过冻结资产(assets)获得的能量。 如果能量足够，则扣除并返回其余部分。 如果还不够，那么扣除所有能量并转到下一步。

这时会尝试使用事务发起者的TRX，TRX的数量=所需的能量* 20 SUN。

能量计算器工具
为了估算冻结TRX的能量和最大能量限制以部署/触发智能合约，请使用Tron Station能量工具(文末)进行计算。

## 超级代表

投票需要TRON Power，TP的数量取决于选民的冻结资产（TRX）。

TP按以下方式计算：1个TP用于1个冷冻TRX。

超级代表候选人奖励（Vote Reward）：每6小时更新一次的127名候选人将分享115,200 TRX。奖励将根据每位候选人收到的票数进行分配。每年，候选人的总奖励每年将达到168,192,000 TRX

超级代表奖励（Block Reward）：TRON协议网络将每3秒生成一个块，每个块向超级代表授予32 TRX。每年将向27位超级代表颁发336,384,000 TRX。

每当超级代表完成块生产时，奖励将被发送到超级分类账中的子账户。超级代表可以检查，但不能直接使用此资产。可以每24小时提取一次，将奖励从子帐户转移到超级代表的帐户。

**注意：由于网络并不总是3s产生一个块，所以上面的Block Reward得自行计算**

### 奖励计算

总奖励=投票奖励+积分奖励

### Vote Reward

每个块的奖励为16 TRX，每3秒生成一个块，每分钟生成20个块。

Vote Rewards = 16 (TRX/block) *x* 20 (blocks/min) *x* 60 (min/hour) *x* 6 (hours/election) *x* 4 (elections/day) = 460,800 (TRX/day)

**还是由于生成速度不确定，奖励应为	1382400/生成块速度**

### Block Reward

每个块的块奖励为32 TRX，SR逐个创建块。

32 (TRX/block) *x* 20 (blocks/min) *x* 60 (min/hour) *x* 24 (hours/day) = 921,600 (TRX/Day)

**2764800/速度**

## Bandwidth Points

带宽点是每天帐户的可用字节数。在任何给定的时间段内，整个网络处理固定数量的带宽。帐户中的带宽点与TRON网络的带宽容量之比等于帐户中的冻结余额与整个网络上的冻结余额之比。例如，如果整个网络上的冻结资产总计1,000,000 TRX且一个给定帐户冻结了1,000 TRX（冻结TRX总数的0.1％），则该帐户每天可执行大约300笔交易。注意：由于整个网络和某个帐户的冻结资产数量可能会发生变化，因此帐户持有的带宽点并不总是固定的。

### 消耗流程

在正常事务中，带宽点消耗如下：

消耗交易发起人通过冻结资产获得的带宽点数。 如果点数不足，转到下一步。

消耗事务发起者的免费带宽点(每天送的那个)。 如果点数不足，转到下一步。

消耗事务发起者的TRX，计算为交易中的字节数* 10 SUN。

PS:如果交易需要新帐户，则按如下方式使用带宽点数：

消耗事务发起者已冻结获得的带宽点。 如果发起者没有足够的带宽点，转到下一步。

使用事务发起者的TRX，这意味着烧掉0.1TRX。

### 令牌发行转账(Token Issuance Transfer)
如果交易是令牌发放转账，则带宽点消耗如下：

验证已颁发的令牌资产的总可用带宽点是否足够。 然后验证转账发起者的剩余可用带宽点是否足够。 最后，验证令牌发行者已冻结获得的剩余带宽点是否足够。 如果满足这三个要求中的任何一个，则系统从令牌发行者中扣除带宽点。 如果没有，转到下一步。

使用通过冻结资产获得的交易发起者获得的带宽点。 如果不足，转到下一步。

使用事务发起者的免费带宽点。 如果不足，转到下一步。

使用事务发起者的TRX，为transaction中的字节数 * 10 SUN。

### 带宽点消耗

除了查询之外，任何其他类型的交易都会消耗带宽点

1. 如果事务不是令牌转账，则跳到步骤2。如果事务是令牌转账，则TRON尝试从令牌发行方收取带宽点。如果发行方没有足够的带宽点或者费用超出发行方的最大阈值，请转到步骤2。
2. 从交易发起人收取带宽点。 如果带宽点不足：（1）如果交易创建新帐户，请跳至步骤4.（2）如果事务未创建新帐户，请转至步骤3。
3. 从交易发起人收取免费带宽点。 如果可用带宽点不足，请执行步骤4。
4. 将从交易发起人收取TRX费用并烧毁。 （1）对于正常转移，其成本约为0.002 TRX。 （2）如果交易创建了新账户，则成本约为0.1 TRX。 注意：当余额解冻时，由于不再有冻结的TRX，因此将清除带宽点。

从这里可以看出创建账户不能使用免费带宽点

还有一个例外。 如果目标帐户在转帐或令牌发放中不存在，则会创建一个新帐户并完成转帐。 在这种情况下，将仅扣除帐户创建所消耗的带宽点。 转账不会占用额外的带宽点。

### 带宽点之源
每个帐户每天免费提供5000个带宽点。 当帐户未冻结任何余额或其带宽点已用完时，可以使用免费带宽点。 TRON网络中的每个事务大约是200字节，因此每个帐户每天免费享受大约25笔交易。



# 从代码看(待续)

## 部分函数解释

`dbManager.adjustBalance(ownerAddress, -fee);`显而易见

`dbManager.adjustBalance(dbManager.getAccountStore().getBlackhole().getAddress().toByteArray(),fee);//send to blackhole`发送fee到一个Map类型，其中key是"blackhole"，不清楚为啥要这么做，难道是fee守恒定理？

`public long calcFee()`这个函数是用来计算`fee`的，每个类型的合约计算方式不一样

**有一段关于Frozen的代码，还没看懂

## 发布Token(AssetIssue)

```
public long calcFee() {
    return dbManager.getDynamicPropertiesStore().getAssetIssueFee();
}
```

```
dbManager.adjustBalance(ownerAddress, -fee);
dbManager.adjustBalance(dbManager.getAccountStore().getBlackhole().getAddress().toByteArray(), fee);
```

这里的 `calcFee()`套了N层，还没看懂怎么算

## 买储存(BuyStorage)

```
public long calcFee() {
  return 0;
}
```

```
long quant = buyStorageContract.getQuant();
storageMarket.buyStorage(accountCapsule, quant);
```

## 创建账户(CreateAccount)

```
public long calcFee() {
  return dbManager.getDynamicPropertiesStore().getCreateNewAccountFeeInSystemContract();
}
```















# 其他

https://tronstation.io